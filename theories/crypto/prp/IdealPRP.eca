(* --------------------------------------------------------------------
 * Copyright (c) - 2012--2016 - IMDEA Software Institute
 * Copyright (c) - 2012--2016 - Inria
 *
 * Distributed under the terms of the CeCILL-B-V1 license
 * -------------------------------------------------------------------- *)

require import Option FSet NewFMap Distr.
require import Dexcepted.
require (*--*) NewPRP.

clone include NewPRP.

op dD: D distr.
axiom dD_ll: mu dD predT = 1%r.

module RandomPermutation = {
  var m : (D,D) fmap
  var mi: (D,D) fmap

  proc init(): unit = {
    m  <- map0;
    mi <- map0;
  }

  proc f(x:D): D = {
    var y;

    if (!mem (dom m) x) {
      y      <$ dD \ (rng m);
      m.[x]  <- y;
      mi.[y] <- x;
    }
    return (oget m.[x]);
  }

  proc fi(y:D): D = {
    var x;

    if (!mem (dom mi) y) {
      x      <$ dD \ (rng mi);
      mi.[y] <- x;
      m.[x]  <- y;
    }
    return (oget mi.[y]);
  }
}.

pred is_permutation (m mi : (D,D) fmap) =
     (forall x, mem (dom m) x => mi.[oget m.[x]] = Some x)
  /\ (forall x, mem (dom mi) x => m.[oget mi.[x]] = Some x).

equiv f_perm: RandomPermutation.f ~ RandomPermutation.f:
     ={glob RandomPermutation, x}
  /\ is_permutation RandomPermutation.m{1} RandomPermutation.mi{1}
  ==>    ={glob RandomPermutation, res}
      /\ is_permutation RandomPermutation.m{1} RandomPermutation.mi{1}.
proof.
proc; if=> //=; auto.
progress [-split]; rewrite H1 /=.
move: H1; rewrite supp_def -/(support _ _)=> -[yL_in_dD y_notin_rng].
split=> x'.
  rewrite !getP dom_set !inE; case: (x' = x{2})=> //= _.
  by move: y_notin_rng; rewrite in_rng; smt. (* !exists <=> forall! *)
rewrite !getP dom_set !inE; case: (x' = yL)=> //=.
smt. (* equivalence of rng mi and dom m + similar argument *)
qed.

equiv fi_perm: RandomPermutation.fi ~ RandomPermutation.fi:
     ={glob RandomPermutation, y}
  /\ is_permutation RandomPermutation.m{1} RandomPermutation.mi{1}
  ==>    ={glob RandomPermutation, res}
      /\ is_permutation RandomPermutation.m{1} RandomPermutation.mi{1}.
proof.
proc; if=> //=; auto.
progress [-split]; rewrite H1 /=.
move: H1; rewrite supp_def -/(support _ _)=> -[xL_in_dD x_notin_rng].
split=> x'.
  rewrite !getP dom_set !inE; case: (x' = xL)=> //= _.
  by move: x_notin_rng; rewrite in_rng; smt.
rewrite !getP dom_set !inE; case: (x' = y{2})=> //=.
smt.
qed.
