(* --------------------------------------------------------------------
 * Copyright (c) - 2012--2015 - IMDEA Software Institute
 * Copyright (c) - 2012--2015 - Inria
 * 
 * Distributed under the terms of the CeCILL-B-V1 license
 * -------------------------------------------------------------------- *)

(* -------------------------------------------------------------------- *)
require import Option Pred Fun Int IntExtra Real List Distr.
require import NewDistr StdOrder.
require (*--*) FinType Tuple.
(*---*) import RealOrder IntOrder.

(* -------------------------------------------------------------------- *)
clone import FinType as Alphabet.

op n : {int | 0 <= n} as ge0_n.

type word.

op mkword : t list -> word.
op ofword : word -> t list.

op wordw = nseq n witness<:t>.

(* -------------------------------------------------------------------- *)
lemma nosmt size_wordw: size wordw = n.
proof. by rewrite size_nseq max_ler ?ge0_n. qed.

axiom nosmt mkwordK    : cancel ofword mkword.
axiom nosmt ofwordK    : forall s, size s =  n => ofword (mkword s) = s.
axiom nosmt mkword_out : forall s, size s <> n => ofword (mkword s) = wordw.

lemma nosmt size_word : forall w, size (ofword w) = n.
proof.
move=> w; rewrite -mkwordK; case: (size (ofword w) = n).
by rewrite mkwordK. by move/mkword_out=> ->; rewrite size_wordw.
qed.

lemma nosmt mkwordW (P : word -> bool):
     (forall s, size s = n => P (mkword s))
  => forall n, P n.
proof. by move=> ih n; rewrite -mkwordK; apply/ih/size_word. qed.

lemma nosmt ofword_inj : injective ofword.
proof. by apply/(can_inj _ _ mkwordK). qed.

(* -------------------------------------------------------------------- *)
op "_.[_]" (w : word) (i : int): t =
  nth witness (ofword w) i
axiomatized by getE.

op "_.[_<-_]" (w : word) (i : int) (x : t) : word =
  mkword (mkseq (fun k => if i = k then x else w.[k]) n)
axiomatized by setE.

(* -------------------------------------------------------------------- *)
lemma wordP (w1 w2 : word):
  w1 = w2 <=> forall i, 0 <= i < n => w1.[i] = w2.[i].
proof.
split=> // ih; apply/ofword_inj/(eq_from_nth witness); rewrite ?size_word //.
by move=> i ?; rewrite -!getE ih.
qed.

(* -------------------------------------------------------------------- *)
lemma wordW (P : word -> bool):
     (forall s, size s = n => P (mkword s))
  => forall w, P w.
proof. by move=> ih n; rewrite -mkwordK; apply/ih/size_word. qed.

(* -------------------------------------------------------------------- *)
lemma get_set_if (w : word) (x : t) (i j : int):
  w.[i <- x].[j] = if 0 <= i < n /\ j = i then x else w.[j].
proof.
elim/wordW: w=> w szw; rewrite !(setE, getE) ofwordK.
  by rewrite size_mkseq max_ler ?ge0_n.
rewrite nth_mkseq_if /= (eq_sym i) getE; case: (j = i)=> [->|ne_ji] /=.
  by case: (0 <= i < n)=> // h; rewrite nth_out ?ofwordK ?szw.
by rewrite ofwordK //; case: (0 <= j < n)=> // h; rewrite nth_out ?szw.
qed.

(* -------------------------------------------------------------------- *)
lemma get_set (w : word) (x : t) (i j : int): 0 <= i < n =>
  w.[i <- x].[j] = if j = i then x else w.[j].
proof. by move=> lt_in; rewrite get_set_if lt_in. qed.

(* -------------------------------------------------------------------- *)
lemma set_out (i : int) (x : t) (w : word):
  ! (0 <= i < n) => w.[i <- x] = w.
proof.
by move=> Nlt_in; apply/wordP=> j _; rewrite get_set_if  Nlt_in.
qed.

(* -------------------------------------------------------------------- *)
lemma set_neg (i : int) (a : t) (w : word):
  i < 0 => w.[i<- a] = w.
proof. by move=> lt0_i; rewrite set_out // lezNgt lt0_i. qed.

(* -------------------------------------------------------------------- *)
lemma set_above (i : int) (a : t) (w : word):
  n <= i => w.[i <- a] = w.
proof. by move=> le_ni; rewrite set_out // ltzNge le_ni. qed.

(* -------------------------------------------------------------------- *)
lemma set_set_if (w : word) (k k' : int) (x x' : t):
       w.[k <- x].[k' <- x']
    =  if   k = k'
       then w.[k' <- x']
       else w.[k' <- x'].[k <- x].
proof.
apply/wordP=> i lt_in; case: (0 <= k < n)=> [lt_kn|]; last first.
  by move=> ?; rewrite !(set_out k).
case: (0 <= k' < n)=> [lt_k'n|]; last first.
  by move=> ?; rewrite !(set_out k') //; case: (k = k').
have /= -> := fun_if (fun w => w.[i]); rewrite !get_set //.
case: (k = k') => [->>|]; first by case: (i = k').
by case: (i = k') => //; case: (i = k).
qed.

(* -------------------------------------------------------------------- *)
lemma set_set_eq (w : word) (k : int) (x x' : t):
  w.[k <- x].[k <- x'] = w.[k <- x'].
proof. by rewrite set_set_if. qed.

(* -------------------------------------------------------------------- *)
lemma set_set_swap (w : word) (k k' : int) (x x' : t):
  k <> k => w.[k <- x].[k' <- x'] = w.[k' <- x'].[k' <- x'].
proof. by rewrite set_set_if. qed.

(* -------------------------------------------------------------------- *)
op offun f: word = mkword (mkseq f n).

lemma offunE f i: 0 <= i < n => (offun f).[i] = f i.
proof.
move=> lt_in; rewrite getE ofwordK 2:nth_mkseq //.
by rewrite size_mkseq // max_ler ?ge0_n.
qed.

(* -------------------------------------------------------------------- *)
op map (f : t -> t) (w : word) : word = mkword (map f (ofword w)).

lemma mapE f w i: 0 <= i < n => (map f w).[i] = f w.[i].
proof.
elim/wordW: w => w szw; move=> lt_in; rewrite !getE.
by rewrite ofwordK ?size_map ?ofwordK //; apply/nth_map; rewrite szw.
qed.

(* -------------------------------------------------------------------- *)
clone Tuple as Enum with
  type t <- t,
    op Support.enum <- enum
proof * by exact/enum_spec.

(* -------------------------------------------------------------------- *)
clone include FinType with
  type t    <- word,
    op enum = map mkword (Enum.wordn n)
proof * rename [op] "enum" as "words".

realize enum_spec.
proof.
move=> x; rewrite count_map -(Enum.word_spec n (ofword x) _).
  by rewrite size_word max_ler 1:ge0_n.
apply/eq_in_count=> s /Enum.wordnP sx; rewrite !pred1E /preim.
by rewrite -(can_eq _ _ mkwordK) ofwordK // /valid sx max_ler 1:ge0_n.
qed.

(* -------------------------------------------------------------------- *)
lemma word_card: card = Alphabet.card^n.
proof. by rewrite size_map Enum.size_wordn max_ler ?ge0_n. qed.

(* -------------------------------------------------------------------- *)
theory Wordw.
import MUniform.

op dword : word distr = duniform words.

lemma muP p: mu dword p = (count p words)%r / (Alphabet.card^n)%r.
proof. by rewrite duniformE !undup_id ?enum_uniq // -word_card. qed.

lemma muxP w: mu dword (pred1 w) = 1%r / (Alphabet.card^n)%r.
proof. by rewrite muP count_uniq_mem 1:enum_uniq// enumP. qed.

lemma supportP w: support dword w.
proof.
rewrite /support /in_supp muxP divr_gt0 //.
by rewrite from_intM; apply/powPos/Alphabet.card_gt0.
qed.

lemma dword_ll: mu dword predT = 1%r.
proof.
apply/duniform_ll; apply/negP=> zw; move: (enumP witness).
by rewrite zw.
qed.
end Wordw.
